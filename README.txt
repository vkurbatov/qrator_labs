Василий, добрый день.
Как договаривались, направляем Вам тестовое задание:

Условия

• Задачи можно реализовать как на C, так и на C++

• В случае C++ реализовывать нужно без использования C++11 и выше (он у нас и используется, но решение на нём будет слишком простым).

• На решение отводится два дня.
Задача 1 (массив)
• Дан массив различных целых чисел. Надо найти индекс локального минимума в этом массиве.
• Необходимо реализовать алгоритм с минимальной асимптотической сложностью.

• Локальный минимум - это такой элемент массива a_i, что a_{i-1} > a_i < a_{i+1}. Для начала и конца массива, соответственно: a0 < a1 и a_n < a_{n-1}.
Задача 2 (сортировка)

• Дан массив различных целых чисел.

• Мы хотим отсортировать его следующим образом: a0 > a1 > a2 > … > a_{k-1} > a_k < a_{k+1} < a_{k+2} < … a_N, 0 <= k <= N.

• При этом единственная допустимая операция: поменять местами два соседних элемента.

• Необходимо написать функцию вида int n_swaps(int *a, size_t size), возвращающую минимально необходимое количество операций, которые приводят массив к данному виду.

• Обратите внимание, что индекс k может быть с краю (то есть, отсортированный список уже обладает нужным порядком элементов), а также что k не является параметром функции, а должен получаться в результате работы алгоритма.

Задача 3 (ThreadPool)
Реализовать ThreadPool:


• при создании указывается один параметр - число воркеров, которые будут выполнять задачи.

◦ метод Enqueue имеет два параметра - объект(ссылку на объект), описывающий задачу, которую надо будет выполнить (например абстрактного типа с методом .do()) и приоритет(пусть всего будет три приоритета - low, normal, high).

◦ метод Stop() - ожидает завершения выполняемых (в данный момент) задач, после чего убивает воркеры и возвращает управление.

• Enqueue добавляет задачи в очередь на выполнение и возвращает true (если до этого не был вызван Stop - в этом случае Enqueue возвращает false).
• Приоритеты обрабатываются следующим образом:

◦ low-задачи не выполняются никогда, пока в очереди есть хотя бы одна задача с другим приоритетом.

◦ на 3 high-задачи выполняется 1 normal-задача.

◦ Данная логика относится только к выборке задачи из очереди, уже запущенные задачи приоритизировать не требуется.

Вопросы по тестовому заданию направляйте, пожалуйста, нашему техлиду Андрею. 
Его мейл:
Serenheit@qrator.net
Меня ставьте в копию. 
Мой мейл: jk@qrator.net
